以下提及的数据的运行环境，CPU为AMD Ryzen 3600 6c12t，内存为16G 3600Mhz

## SerialGC

GC时会触发线程暂停，由单个GC线程执行垃圾回收操作

串行GC的old区的GC暂停时间随着old区空间大小的增加有显著的上升，根据GCLogAnalysis类在不同堆大小下运行的GC日志，得到数据如下：

* 最大堆为256M，其他参数默认的情况下，old代的大小为174784K，平均的old代GC暂停时间为0.019s
* 最大堆为512M，其他参数默认，old代大小为349568K，平均old代GC暂停时间为0.03s
* 最大堆为1024M，其他参数默认，old代大小为699072K，平均old代GC暂停时间为0.04s

young区的GC暂停时间增长情况与old类似，随着空间大小的增加也有显著的上升，在young区大小为314560K的情况下，平均GC暂停时间为0.03s左右。

基于串行GC的暂停时间随着堆大小增长幅度比较大，且暂停时间也比较长，因此串行GC并不适用于堆内存空间比较大的情况，以及对延迟要求比较高的情况。

## ParallelGC

并行GC相比于串行GC，提供了并行执行垃圾回收的能力，可以有效的利用多核CPU的并行处理能力。

使用GCLogAnalysis类的gc日志结果统计，得到数据如下：

* 最大堆为256M，YoungGC的平均执行时间为0.004s，FullGC的平均执行时间为0.015
* 最大堆为512M，YoungGC的平均执行时间为0.009s，FullGC的平均执行时间为0.025
* 最大堆为1024M，YoungGC的平均执行时间为0.010s，FullGC的平均执行时间为0.035

由于并行GC的FullGC执行过程中也会执行Young区的GC，所以对Old代的GC时间实际上会短一些。

从上面的数据与串行GC的对比可知，并行GC在利用了多核CPU的并行能力之后，GC时间有了明显的缩短（实际上由于在GC过程中可能会有其他的固定开销导致相比单线程执行并没有缩短太多，但是在遇到堆比较大的时候会更加的明显一些）。但是与串行GC类似，整体的GC时间随着堆空间大小的增长也有显著的上升，因此相比较与串行GC来说在相同的GC暂停时间的情况下并行GC支持更大的堆空间大小，但是在更大的堆大小的情况下GC暂停时间仍然是不可接受的。

总的来说，并行提升了GC处理速度降低了GC暂停时间，但是仍然存在在较大的堆空间中暂停时间较长的问题，同样不适用于较大的堆。

## CMS GC

CMSGC的设计目标就是避免Old代在GC回收时产生长时间的暂停，因此在老年代的回收过程上做了很大的改变，在young区的回收依旧使用相同的并行STW方式的标记复制算法。

CMS的Old区GC可以简单的总结为两点，一是使用空闲列表来管理可用的内存空间，二是部分回收过程与应用线程并发执行。

CMSGC的Old代回收一共分为了六个步骤：

1. 初始标记，触发STW暂停
2. 并发标记
3. 并发预清理
4. 最终标记，触发STW暂停
5. 并发清理
6. 并发重置

整个过程中，只有初始标记和最终标记两个阶段会导致线程暂停，其他的阶段都是与应用线程并发执行。

运行GCLogAnalysis类，根据gc日志结果统计，在最大堆为1024M的情况下，初始标记阶段的平均耗时是0.0002s，最终标记阶段为0.0012s，加起来是0.0014s，相比较于并行GC的OldGC暂停时间缩短了非常多。即使是在最大堆为2048M的情况下GC暂停时间也没有明显增长，非常适合堆空间较大，且对延迟要求较高的情况。

但是CMSGC也存在着一下几点问题：

1. 在并发预清理阶段到最终标记阶段之间，应用线程与GC线程并发执行的过程中，依然在产生着垃圾对象，如果产生垃圾对象的速度较快，Young区频繁GC，进而导致大量对象晋升到Old区，由于此时Old区的空间已经不太足够，所以非常容易触发晋升失败PromotionFailed与并发模式失败Concurrent Mode Failed，导致CMSGC退化为单线程的串行GC模式，线程暂停时间超长。
2. 在初始标记阶段之后晋升到Old区的对象，不会被当前进行中的并发GC回收，可能会导致一次并发GC执行完之后Old区的内存占用率还是比较高，再次触发了并发GC。
3. 由于CMS的Old代回收过程中并没有进行存货对象的整理，存在没有足够的连续空间存放大对象的问题，导致晋升失败，继而退化为串行GC。
4. 并发GC过程中，GC线程占用CPU资源和内存资源，导致应用进程的吞吐量降低

## G1GC

G1GC的设计目标是可预期和可配置的GC暂停时间，在应用执行过程中G1会收集多次GC过程中的信息，最终尽可能把GC暂停时间控制在预期暂停时间左右。

G1GC相比其他的GC算法，最显著的改变是把整个堆空间切分成一个个的小块，称为Region。Region有三种类型，分别是Old、Eden和Survivor，在同一时间只能是其中一种类型，在运行期间可以根据需要变换类型。在回收时候，优先回收包含了较多垃圾对象的Region。

G1GC在每次回收的时候并不会回收掉所有的垃圾对象，而是每次只回收一部分，并通过控制每次回收的Region数量，来实现控制回收过程中线程暂停时间。具体每次要回收哪些Region，则是由并发并发标记过程来整理出优先要清理的Region。

G1GC的回收有young回收和mixed回收两种回收操作，前者只回收young类型的Region，将存活的对象拷贝到Survivor类型的Region中；后者则是同时清理young类型的Region和一部分Old类型的Region。

与CMSGC的退化问题类似，在G1GC中同样存在并发失败、晋升失败和大对象分配失败时退化为串行GC的问题，在使用的时候需要根据实际情况调整G1GC的各项配置参数以避免这种情况。

总的来说，G1GC具有以下几个优点：

1. GC暂停时间可预期可配置
2. 堆空间较大时GC线程暂停时间较低，且暂停时间长短可控。

相对的G1GC也存在一些问题：

1. 和CMS一样，与业务线程并发执行的GC线程会占用CPU和内存资源，导致业务线程吞吐量降低
2. 在一些情况下会退化成单线程FullGC，暂停时间非常长。

## 总结

* SerialGC存在效率低，GC暂停时间随着堆容量增加而显著上升的问题，但是在空间较小的堆中以及对延迟要求不高的场合也还算不错。
* ParallelGC充分利用多核CPU的并行处理能力提升垃圾回收的速度，降低了GC暂停时间，但是仍然存在随着堆容量增加而显著上升的问题，但是与CMS和G1相比，不会对业务线程的吞吐量造成影响，适用于堆比较小且吞吐量优先的场合。
* CMS GC对空间较大的堆支持比较好，由于GC过程中大部分时间与应用线程并发执行，因此对响应速度没有太大的影响，但是会占用一部分系统资源，因此对吞吐量有一定影响，适合低延迟优先以及堆空间较大的场合。
* G1 GC是JDK新版本中主推的GC算法，后续JDK会持续提供改进优化，比起CMS GC来说GC暂停时间比较稳定可控，支持更大的堆容量，且对中小型堆空间的适用性也不错，缺点和CMSGC也差不多，是CMS的全面改进优化版本，可以替代CMS GC。

